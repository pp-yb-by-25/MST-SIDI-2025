ğŸ“± ANDROID â€“ EXERCICES AVEC CODES Ã€ COMPLÃ‰TER

(par chapitre â€“ niveau dÃ©butant â†’ intermÃ©diaire)

ğŸŸ¦ CHAPITRE 1 : Introduction, Architecture et Cycle de vie
A. Vrai / Faux (justifier)

    Android repose sur un noyau Linux modifiÃ©. vrai

    Le noyau Linux gÃ¨re directement lâ€™interface graphique. 

    ART compile le code au moment de lâ€™installation de lâ€™application.

    Dalvik compile le code Ã  chaque lancement.

    Une activitÃ© est toujours dÃ©truite quand elle devient invisible.

    Une application Android peut contenir plusieurs activitÃ©s.

    Android Studio est basÃ© sur IntelliJ IDEA.

    Le fichier AndroidManifest.xml est optionnel.

    Une application Android peut fonctionner sans interface graphique.

    Le cycle de vie est gÃ©rÃ© automatiquement par Android.

B. Questions de comprÃ©hension

    Citer et expliquer les couches de lâ€™architecture Android.

    Pourquoi Android utilise-t-il un cycle de vie pour les activitÃ©s ?

    Quelle est la diffÃ©rence entre :

    Application

    ActivitÃ©

    Pourquoi Android peut dÃ©truire une activitÃ© sans prÃ©venir ?

C. ğŸ§© Code Ã  complÃ©ter â€“ Cycle de vie (fondamental)

    ComplÃ©ter les mÃ©thodes dans lâ€™ordre correct du premier lancement :

    @Override
    protected void __________() {   // [1]
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    @Override
    protected void __________() {   // [2]
        super.onStart();
    }

    @Override
    protected void __________() {   // [3]
        super.onResume();
    }

D. ğŸ§© Code Ã  complÃ©ter â€“ Changement dâ€™Ã©tat

    ComplÃ©ter les mÃ©thodes appelÃ©es lorsque lâ€™utilisateur quitte lâ€™activitÃ© :

    @Override
    protected void __________() {   // [4]
        super.onPause();
    }

    @Override
    protected void __________() {   // [5]
        super.onStop();
    }

    @Override
    protected void __________() {   // [6]
        super.onDestroy();
    }

ğŸŸ¦ CHAPITRE 2 : Conception de lâ€™interface utilisateur (UI)
A. Vrai / Faux

    Toutes les vues hÃ©ritent de la classe View.

    LinearLayout permet uniquement un alignement horizontal.

    ConstraintLayout rÃ©duit la profondeur de la hiÃ©rarchie.

    wrap_content prend toute la largeur de lâ€™Ã©cran.

    dp est indÃ©pendant de la densitÃ© de pixels.

    sp est recommandÃ© pour le texte.

    Un ViewGroup peut contenir dâ€™autres ViewGroup.

    Chaque vue doit avoir un id.

    XML dÃ©finit le comportement logique de lâ€™application.

    On peut crÃ©er une interface sans XML.

B. Attributs XML â€“ expliquer

    android:layout_width

    android:layout_height

    android:orientation

    android:gravity

    android:layout_margin

    android:padding

    android:id

C. ğŸ§© Code XML Ã  complÃ©ter â€“ Layout simple

ComplÃ©ter ce layout pour afficher :

un champ de texte

un bouton en dessous

<LinearLayout
    android:layout_width="__________"
    android:layout_height="__________"
    android:orientation="__________"
    android:padding="16dp">

    <EditText
        android:id="@+id/edt_nom"
        android:layout_width="__________"
        android:layout_height="__________"
        android:hint="__________"/>

    <Button
        android:id="@+id/btn_valider"
        android:layout_width="__________"
        android:layout_height="__________"
        android:text="Valider"/>
</LinearLayout>

D. ğŸ§© Code XML â€“ Attributs avancÃ©s

ComplÃ©ter les attributs pour ajouter un espace de 20dp au-dessus du bouton :

<Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Envoyer"
    android:__________="20dp"/>

ğŸŸ¦ CHAPITRE 3 : Programmation dâ€™une activitÃ©
A. Vrai / Faux

    R.java est gÃ©nÃ©rÃ© automatiquement.

    Une erreur XML empÃªche la compilation.

    setContentView() est obligatoire.

    findViewById() relie Java au XML.

    On peut manipuler une vue sans id.

    TextWatcher dÃ©tecte les changements de texte.

    OnClickListener est une classe abstraite.

    Toast affiche un message permanent.

    Une activitÃ© peut gÃ©rer plusieurs Ã©vÃ©nements.

    Java contrÃ´le la logique, XML lâ€™affichage.

B. ğŸ§© Code Ã  complÃ©ter â€“ Liaison XML / Java
    EditText edt_note;
    Button btn_calculer;
    TextView tv_resultat;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        edt_note = __________(R.id.edt_note);   // [1]
        btn_calculer = __________(R.id.btn_calculer); // [2]
        tv_resultat = __________(R.id.tv_resultat);   // [3]
    }

    C. ğŸ§© Code Ã  complÃ©ter â€“ Interaction utilisateur
    btn_calculer.__________(new View.OnClickListener() {   // [4]
        @Override
        public void onClick(View v) {

            String txt = edt_note.getText().toString().__________(); // [5]
            float note = Float.__________(txt); // [6]

            String resultat = "Note : " + note;
            tv_resultat.__________(resultat); // [7]
        }
    });

ğŸŸ¦ CHAPITRE 4 : Intents et communication
A. Vrai / Faux

    Intent est un mÃ©canisme de communication.

    Intent explicite cible une classe prÃ©cise.

    Intent implicite cible une application prÃ©cise.

    putExtra() transmet des donnÃ©es.

    Les clÃ©s sont obligatoires.

    Une activitÃ© peut recevoir plusieurs extras.

    startActivity() attend un rÃ©sultat.

    Intent sert aussi aux services.

    Sans Intent, pas de navigation.

    Intent est dÃ©fini dans le Manifest.

B. ğŸ§© Code Ã  complÃ©ter â€“ Envoi de donnÃ©es
    Intent intent = new Intent(MainActivity.this, ResultActivity.class);
    intent.__________("cle_score", score); // [1]
    __________(intent); // [2]

    C. ğŸ§© Code Ã  complÃ©ter â€“ RÃ©ception
    Intent i = getIntent();
    int score = i.__________("cle_score", 0); // [3]

ğŸŸ¦ CHAPITRE 5 : Sauvegarde des donnÃ©es
A. Vrai / Faux

    SharedPreferences stocke des paires clÃ©-valeur.

    Les donnÃ©es sont privÃ©es par dÃ©faut.

    Le stockage interne est accessible par toutes les apps.

    SQLite est une base relationnelle.

    SQLite fonctionne sans Internet.

    Cursor contient les rÃ©sultats.

    SQLite nÃ©cessite un serveur.

    SharedPreferences est adaptÃ© aux rÃ©glages.

    Une base SQLite est supprimÃ©e Ã  la dÃ©sinstallation.

    Le stockage externe nÃ©cessite une permission.

B. ğŸ§© Code Ã  complÃ©ter â€“ SharedPreferences
    SharedPreferences prefs = getSharedPreferences("mon_fichier", MODE_PRIVATE);
    SharedPreferences.Editor editor = prefs.__________(); // [1]

    editor.__________("username", nom); // [2]
    editor.__________(); // [3]

C. ğŸ§© Code Ã  complÃ©ter â€“ Lecture
    SharedPreferences prefs = getSharedPreferences("mon_fichier", MODE_PRIVATE);
    String nom = prefs.__________("username", ""); // [4]